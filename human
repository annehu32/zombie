from Tufts_ble import Sniff, Yell
import uasyncio as asyncio
from machine import Pin, PWM
import time
import neopixel


# Central listens - human function
async def central():
    c = Sniff('!', verbose = True)
    c.scan(0)   # 0ms = scans forever 
    for i in range(100):
        latest = c.last
        if latest:
            c.last='' # clear the flag for the next advertisement
            print('Got: ' + latest)
        await asyncio.sleep(0.1)

# Peripheral yells - zombie function
async def peripheral():    
    p = Yell()
    for i in range(100):
        p.advertise(f'!2{i}')
        await asynctio.sleep(0.1)
    p.stop_advertising()

# defining pins that we'll be needing...
# want 3 indicator lights, buzzer, neopixel to indiciate state
buzzer = PWM(Pin('GPIO18', Pin.OUT))  # buzzer
neo = neopixel.NeoPixel(Pin(28), 1)   # neopixel
firstHit = Pin('GPIO0', Pin.OUT)
secondHit = Pin('GPIO1', Pin.OUT)
thirdHit = Pin('GPIO2', Pin.OUT)

# Thinking through the architecture for a human:
    # A human listens for a zombie yelling
    # when a zombie enters range, call function
hit_list = [0] * 13 # List to track our hits
print(hit_list)
isHuman = True # will turn false when get 3 hits from the same number
killedBy = -1 # setting this variable to -1 so that we never mis-read. 

# upon zombie entering range, want to check how long they're there
async def readHit(num):
    

# The human loop runs until a call to read_hit breaks the loop
while isHuman:
    central()
        # if zombie in range, call readHit(zombie number)
